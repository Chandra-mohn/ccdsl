(* ========================================== *)
(* Credit Card DSL - Complete Formal Grammar *)
(* ========================================== *)
(* EBNF Notation - ISO/IEC 14977 *)
(* Status: Complete specification *)
(*
   Features:
   - Entity definitions (9 data mutation patterns)
   - Workflow definitions (traditional and pipeline syntax)
   - Rule definitions (procedural and decision tables)
   - Parameter definitions (PCF)
   - Reference data definitions
   - Error strategies and configuration
   - Action definitions
*)
(* ========================================== *)

(* ========================================== *)
(* ROOT PRODUCTION *)
(* ========================================== *)

dsl_file = { definition } ;

definition =
    entity_definition
  | workflow_definition
  | rule_definition
  | parameter_definition
  | reference_data_definition
  | error_strategy_definition
  | configuration_block
  | action_definition ;


(* ========================================== *)
(* ENTITY DEFINITIONS (v1.0) *)
(* ========================================== *)

entity_definition =
    "define", "entity", ":", identifier,
    pattern_declaration,
    [ business_domain ],
    [ description ],
    { field_group },
    [ relationships ],
    [ constraints ] ;

pattern_declaration =
    "pattern", ":", pattern_name ;

pattern_name =
    "master_data"
  | "immutable_ledger"
  | "versioned_configuration"
  | "operational_parameters"
  | "event_log"
  | "state_machine"
  | "temporal_data"
  | "reference_data"
  | "business_logic" ;

field_group =
    identifier, ":", { field_definition } ;

field_definition =
    identifier, ":", type_spec, { type_qualifier } ;

type_spec =
    "text" | "number" | "money" | "date" | "datetime" |
    "boolean" | "phone" | "email" | "ssn" | "percentage" | "duration" ;

type_qualifier =
    "required" | "optional" | "unique" | "encrypted" |
    "cannot_change" | "system_managed" |
    ( "between", expression, "and", expression ) |
    ( "values", ":", enum_values ) |
    ( "default", ":", literal ) ;

enum_values = literal, { "|", literal } ;

relationships =
    "relationships", ":", { relationship_declaration } ;

relationship_declaration =
    ( "belongs_to" | "has_many" | "has_one" ), ":", identifier ;

constraints =
    "must", ":", { constraint_expression } ;

constraint_expression =
    "-", expression ;


(* ========================================== *)
(* WORKFLOW DEFINITIONS (v3.0) *)
(* ========================================== *)

workflow_definition =
    "define", "workflow", ":", identifier,
    [ business_domain ],
    [ description ],
    [ triggered_by ],
    [ inputs ],
    [ outputs ],
    { workflow_step } ;

workflow_step =
    "step", ":", identifier,
    [ description ],
    "actions", ":", action_block,
    ( next_logic | return_statement ) ;

(* Action Block - supports both traditional and pipeline syntax *)
action_block =
    { action_statement } ;

action_statement =
    "-", ( traditional_action | pipeline_expression | variable_assignment | control_structure ) ;

(* Traditional Actions (v2.0 - backward compatible) *)
traditional_action =
    action_call
  | for_each_loop
  | if_statement
  | create_statement
  | update_statement
  | delete_statement
  | notification_statement ;

action_call =
    identifier, [ "(", argument_list, ")" ] ;

for_each_loop =
    "for", "each", identifier, "in", expression, ":", { action_statement } ;

if_statement =
    "if", expression, ":", { action_statement },
    [ "else", ":", { action_statement } ] ;

(* Pipeline Expressions (v3.0 - preferred) *)
pipeline_expression =
    entity_source, { pipeline_operator } ;

entity_source =
    identifier                                      (* Simple entity reference *)
  | identifier, "where", filter_condition          (* Filtered source *)
  | "(", subquery, ")" ;                           (* Subquery *)

pipeline_operator =
    "|", (
        filter_operator
      | map_operator
      | foreach_operator
      | reduce_operator
      | join_operator
      | group_by_operator
      | order_by_operator
      | take_operator
      | aggregation_operator
      | error_handling_operator
    ) ;

(* Pipeline Operator Definitions *)
filter_operator =
    "filter", ":", condition ;

map_operator =
    "map", ":", transformation ;

foreach_operator =
    "foreach", ":", action_call ;

reduce_operator =
    "reduce", ":", aggregation_function ;

join_operator =
    "join", ":", "(", identifier, "=>", identifier, "where", condition, ")" ;

group_by_operator =
    "group_by", ":", identifier ;

order_by_operator =
    "order_by", ":", identifier, [ "asc" | "desc" ] ;

take_operator =
    "take", ":", integer_literal ;

aggregation_operator =
    ( "count" | "sum" | "avg" | "min" | "max" ), ":", identifier ;

error_handling_operator =
    ( "on_validation_error" | "on_calculation_error" | "on_duplicate_key" ),
    ":", identifier ;

transformation =
    identifier, [ "(", argument_list, ")" ] ;

aggregation_function =
    identifier, "(", expression, ")" ;

(* Control Flow *)
next_logic =
    "next", ":", ( goto_statement | conditional_transitions ) ;

goto_statement =
    "goto", identifier ;

conditional_transitions =
    { "when", expression, ":", goto_statement },
    [ "otherwise", ":", goto_statement ] ;

return_statement =
    "return", ":", { return_value } ;

return_value =
    "-", identifier, ":", expression ;


(* ========================================== *)
(* RULE DEFINITIONS (v1.0 + v3.1) *)
(* ========================================== *)

rule_definition =
    "define", "rules", ":", identifier,
    "pattern", ":", "business_logic",
    [ description ],
    { rule_or_decision_table } ;

rule_or_decision_table =
    procedural_rule | decision_table ;

(* Procedural Rules (v1.0) *)
procedural_rule =
    "rule", ":", identifier,
    [ description ],
    [ given_clause ],
    ( calculate_clause | evaluate_clause | validate_clause ),
    [ return_clause ] ;

given_clause =
    "given", ":", { input_parameter } ;

input_parameter =
    "-", identifier, ":", type_spec ;

calculate_clause =
    "calculate", ":", { calculation_expression } ;

calculation_expression =
    identifier, "=", expression ;

evaluate_clause =
    "evaluate", ":", { evaluation_expression } ;

evaluation_expression =
    identifier, "=", boolean_expression ;

validate_clause =
    "validate", ":", { validation_rule } ;

validation_rule =
    "-", expression ;

return_clause =
    "return", ":", { return_parameter } ;

return_parameter =
    "-", identifier, ":", type_spec ;

(* Decision Tables (v3.1 NEW) *)
decision_table =
    "decision_table", ":", identifier,
    [ description ],
    "given", ":", { input_parameter },
    "decide", ":", decision_matrix,
    ( return_specification | execute_specification | hybrid_specification ) ;

(* Decision Matrix *)
decision_matrix =
    table_header,
    { table_row } ;

table_header =
    "|", [ "priority", "|" ], { condition_column_header, "|" },
    "→", { action_column_header, "|" } ;

condition_column_header =
    identifier ;

action_column_header =
    identifier ;

table_row =
    "|", [ integer_literal, "|" ], { condition_cell, "|" },
    "→", { action_cell, "|" } ;

(* Condition Cells *)
condition_cell =
    exact_match
  | range_condition
  | comparison_condition
  | complex_expression
  | function_call
  | in_condition
  | not_in_condition
  | wildcard ;

exact_match =
    literal ;

range_condition =
    numeric_range | money_range | date_range ;

numeric_range =
    numeric_literal, "-", numeric_literal ;

money_range =
    money_literal, "-", money_literal ;

date_range =
    date_literal, "-", date_literal
  | expression, "+", duration_literal, "-", expression, "+", duration_literal ;

comparison_condition =
    comparison_operator, expression ;

comparison_operator =
    ">" | ">=" | "<" | "<=" | "=" | "!=" ;

complex_expression =
    "(", boolean_expression, ")",
    [ ( "AND" | "OR" ), complex_expression ] ;

in_condition =
    "IN", "(", value_list, ")" ;

not_in_condition =
    "NOT", "IN", "(", value_list, ")" ;

value_list =
    literal, { ",", literal } ;

wildcard =
    "*" ;

(* Action Cells *)
action_cell =
    literal
  | expression
  | function_call
  | no_action ;

no_action =
    "-" ;

(* Return/Execute Specifications *)
return_specification =
    "return", ":", { return_parameter } ;

execute_specification =
    "execute", ":", ( "yes" | "multi" | identifier ) ;

hybrid_specification =
    return_specification,
    execute_specification ;


(* ========================================== *)
(* ERROR STRATEGY DEFINITIONS (v3.0) *)
(* ========================================== *)

error_strategy_definition =
    "define", "error_strategy", ":", identifier,
    [ description ],
    "on_error", ":", { error_action } ;

error_action =
    "-", action_statement ;


(* ========================================== *)
(* CONFIGURATION BLOCKS (v3.0) *)
(* ========================================== *)

configuration_block =
    "configure", identifier, ":", { config_section } ;

config_section =
    identifier, ":", { config_property } ;

config_property =
    identifier, ":", ( literal | identifier ) ;


(* ========================================== *)
(* ACTION DEFINITIONS (v2.0 Action Library) *)
(* ========================================== *)

action_definition =
    "define", "action", ":", identifier,
    [ description ],
    "parameters", ":", { action_parameter },
    "implementation", ":", action_implementation ;

action_parameter =
    "-", identifier, ":", type_spec, [ "optional" | "required" ] ;

action_implementation =
    "native"                                    (* Built-in action *)
  | "template", ":", { action_statement }      (* DSL template *)
  | "external", ":", string_literal ;          (* External function *)


(* ========================================== *)
(* PARAMETER DEFINITIONS (PCF - v1.0) *)
(* ========================================== *)

parameter_definition =
    "define", "parameters", ":", identifier,
    "pattern", ":", "operational_parameters",
    [ description ],
    { parameter_field } ;

parameter_field =
    identifier, ":", { param_version } ;

param_version =
    "version", identifier, ":", literal, [ ",", "effective", ":", date_literal ] ;


(* ========================================== *)
(* REFERENCE DATA DEFINITIONS (v1.0) *)
(* ========================================== *)

reference_data_definition =
    "define", "reference", ":", identifier,
    "pattern", ":", "reference_data",
    [ description ],
    { reference_entry } ;

reference_entry =
    identifier, ":", literal ;


(* ========================================== *)
(* EXPRESSIONS *)
(* ========================================== *)

expression =
    logical_or_expression ;

logical_or_expression =
    logical_and_expression, { "or", logical_and_expression } ;

logical_and_expression =
    comparison_expression, { "and", comparison_expression } ;

comparison_expression =
    additive_expression, [ comparison_operator, additive_expression ] ;

additive_expression =
    multiplicative_expression, { ( "+" | "-" ), multiplicative_expression } ;

multiplicative_expression =
    unary_expression, { ( "*" | "/" | "%" ), unary_expression } ;

unary_expression =
    [ "not" | "-" ], primary_expression ;

primary_expression =
    literal
  | identifier
  | field_reference
  | function_call
  | "(", expression, ")" ;

field_reference =
    identifier, ".", identifier ;

function_call =
    identifier, "(", [ argument_list ], ")" ;

argument_list =
    argument, { ",", argument } ;

argument =
    [ identifier, ":" ], expression ;

boolean_expression =
    expression ;

condition =
    expression ;

filter_condition =
    expression ;

subquery =
    pipeline_expression ;


(* ========================================== *)
(* STATEMENTS *)
(* ========================================== *)

variable_assignment =
    identifier, "=", expression ;

create_statement =
    "create", identifier, [ "with", ":", field_assignments ] ;

update_statement =
    "update", field_reference ;

delete_statement =
    "delete", identifier ;

notification_statement =
    "send", identifier, "to", identifier ;

field_assignments =
    { "-", identifier, ":", expression } ;


(* ========================================== *)
(* LITERALS *)
(* ========================================== *)

literal =
    string_literal
  | integer_literal
  | decimal_literal
  | money_literal
  | date_literal
  | boolean_literal
  | duration_literal
  | percentage_literal ;

string_literal =
    '"', { character - '"' }, '"' ;

integer_literal =
    digit, { digit } ;

decimal_literal =
    integer_literal, ".", integer_literal ;

money_literal =
    "$", decimal_literal ;

date_literal =
    digit, digit, digit, digit, "-", digit, digit, "-", digit, digit ;

boolean_literal =
    "true" | "false" | "yes" | "no" ;

duration_literal =
    integer_literal, ( "ms" | "s" | "sec" | "min" | "hour" | "day" | "week" | "month" | "year" ) ;

percentage_literal =
    decimal_literal, "%" ;

numeric_literal =
    integer_literal | decimal_literal ;


(* ========================================== *)
(* IDENTIFIERS & KEYWORDS *)
(* ========================================== *)

identifier =
    letter, { letter | digit | "_" } ;

business_domain =
    "business_domain", ":", string_literal ;

description =
    "description", ":", string_literal ;

triggered_by =
    "triggered_by", ":", { "-", string_literal } ;

inputs =
    "inputs", ":", { "-", identifier, ":", type_spec } ;

outputs =
    "outputs", ":", { "-", identifier, ":", type_spec } ;


(* ========================================== *)
(* LEXICAL ELEMENTS *)
(* ========================================== *)

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" |
         "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" |
         "u" | "v" | "w" | "x" | "y" | "z" |
         "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" |
         "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" |
         "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

character = letter | digit | special_char ;

special_char = "!" | "@" | "#" | "$" | "%" | "^" | "&" | "*" | "(" | ")" |
               "-" | "_" | "=" | "+" | "[" | "]" | "{" | "}" | "|" | "\" |
               ";" | ":" | "'" | '"' | "," | "." | "<" | ">" | "/" | "?" |
               " " | "\t" | "\n" | "\r" ;


(* ========================================== *)
(* COMMENTS *)
(* ========================================== *)

(* Single-line comments start with '#' and continue to end of line *)
(* Multi-line comments not supported *)


(* ========================================== *)
(* RESERVED KEYWORDS (Complete List) *)
(* ========================================== *)

(* Entity & Pattern Keywords:
   - define, entity, pattern, business_domain, description
   - master_data, immutable_ledger, versioned_configuration,
     operational_parameters, event_log, state_machine,
     temporal_data, reference_data, business_logic

   Type Keywords:
   - text, number, money, date, datetime, boolean,
     phone, email, ssn, percentage, duration

   Type Qualifiers:
   - required, optional, unique, encrypted, cannot_change,
     system_managed, between, and, values, default

   Relationship Keywords:
   - relationships, belongs_to, has_many, has_one

   Constraint Keywords:
   - must

   Workflow Keywords:
   - workflow, triggered_by, inputs, outputs, step, actions,
     next, when, otherwise, goto, return

   Pipeline Operators (v3.0):
   - filter, map, foreach, reduce, join, group_by, order_by,
     take, count, sum, avg, min, max

   Error Handling (v3.0):
   - on_validation_error, on_calculation_error, on_duplicate_key,
     error_strategy, on_error, configure

   Traditional Action Keywords:
   - for, each, in, if, else, create, update, delete, send, to, with

   Rule Keywords:
   - rules, rule, given, calculate, evaluate, validate

   Decision Table Keywords (v3.1):
   - decision_table, decide, priority, execute

   Action Library Keywords (v2.0):
   - action, parameters, implementation, native, template, external

   Parameter Keywords:
   - parameters, version, effective

   Reference Data Keywords:
   - reference

   Logical Operators:
   - or, and, not, is, IN, NOT IN

   Boolean Literals:
   - true, false, yes, no

   Special Symbols:
   - → (arrow for decision tables)
   - * (wildcard)
   - | (pipe for pipelines and enum separators)
*)


(* ========================================== *)
(* OPERATOR PRECEDENCE *)
(* ========================================== *)

(* Operator precedence (highest to lowest):

   1. Primary: literals, identifiers, field references, function calls, parentheses
   2. Unary: not, - (negation)
   3. Multiplicative: *, /, %
   4. Additive: +, -
   5. Comparison: =, !=, <, <=, >, >=, is, IN, NOT IN
   6. Logical AND: and
   7. Logical OR: or
   8. Pipeline: | (left-to-right chaining)
*)


(* ========================================== *)
(* WHITESPACE & INDENTATION *)
(* ========================================== *)

(* Whitespace (spaces, tabs, newlines) is significant for:
   - Indentation-based block structure (Python-style)
   - List item markers (- prefix)
   - Table row/column separators (| symbol)

   Indentation rules:
   - Use 2 or 4 spaces (consistent within file)
   - Tabs converted to spaces
   - Increased indentation = nested block
   - Decreased indentation = end block

   Table formatting:
   - Pipes (|) separate columns
   - Hyphens (-) for header separator row
   - Arrow (→) separates conditions from actions in decision tables
*)


(* ========================================== *)
(* BACKWARD COMPATIBILITY NOTES *)
(* ========================================== *)

(* v3.1 is fully backward compatible:

   v1.0 Features (fully supported):
   - Entity definitions with all 9 patterns
   - Workflow definitions with traditional actions
   - Procedural rule definitions
   - Parameter definitions (PCF)
   - Reference data definitions

   v2.0 Features (fully supported):
   - Action library (built-in and custom actions)
   - Action templates and external actions

   v3.0 Features (fully supported):
   - Pipeline syntax (preferred for data processing)
   - Error handling operators
   - Configuration blocks
   - Error strategy definitions
   - Traditional actions (backward compatible)

   v3.1 Features (new):
   - Decision tables with full feature set
   - All v3.0 and earlier features remain valid

   Migration path:
   - Use pipeline syntax for new workflows
   - Use decision tables for complex conditional logic
   - Convert workflows incrementally
   - Mix v1.0/v2.0/v3.0/v3.1 syntax during transition
*)


(* ========================================== *)
(* EXAMPLE PRODUCTIONS *)
(* ========================================== *)

(* Example 1: Entity with all features

   define entity: customer
     pattern: master_data
     business_domain: "Customer Agreement (BIAN - 11)"
     description: "Credit card customer account holder"

     identity:
       customer_id: number, unique, required

     profile:
       credit_score: number, between 300 and 850
       account_status: text, values: active | suspended | closed

     relationships:
       has_many: accounts

     must:
       - credit_score >= 300 and credit_score <= 850
       - account_status is one of active | suspended | closed
*)

(* Example 2: Workflow with pipeline syntax

   define workflow: calculate_interest
     triggered_by: scheduled batch job (monthly)

     step: process_accounts
       actions:
         - accounts
             | filter: is_active
             | map: calculate_interest
             | foreach: post_charge
             | sum: total_interest

         - log_event("Complete", amount: total_interest)

       return:
         - total_interest: money
*)

(* Example 3: Decision table

   define rules: late_fee_calculator
     pattern: business_logic

     decision_table: calculate_fee
       given:
         - account_type: text
         - days_late: number

       decide:
         | account_type | days_late | → late_fee |
         |--------------|-----------|------------|
         | premier      | 1-7       | $15        |
         | premier      | 8-30      | $25        |
         | standard     | 1-7       | $35        |
         | standard     | 8-30      | $45        |
         | *            | *         | $50        |

       return:
         - late_fee: money
*)

(* Example 4: Configuration block

   configure error_handling:
     validation_errors:
       default_strategy: skip_and_log
       log_level: warning
       continue_processing: true

     infrastructure_errors:
       default_strategy: retry_then_fail
       max_retries: 3
       backoff_strategy: exponential
*)

(* Example 5: Custom action definition

   define action: send_approval_email
     description: "Send credit approval email to customer"

     parameters:
       - customer: customer, required
       - credit_limit: money, required

     implementation: template
       - load email_template from templates
       - substitute customer.name, credit_limit
       - send email to customer.email
*)


(* ========================================== *)
(* END OF GRAMMAR *)
(* ========================================== *)
